# C++ 数据结构与算法

### 数组

常量数组 

```c++
int arr[10] //长度为10， 但不能求值 arr[10]
```

特点: 内存是连续的，带来了一些优点和缺点：

优点:

1. 下标访问 O(1) arr[n] 与查找注意区分，查找复杂度是 O(n)
2. 末尾位置增加删除元素的时间复杂度是O(1) 指针-- 即可
3. 访问前后相邻的元素非常容易

缺点:

1. 非末尾元素插入时间复杂度 O(n)
2. 无序数组查找时间复杂度是 O(n)
3. 有序数组可以用二分查找，时间复杂度是O(logn)

数组扩容的消耗比较大

---

程序运行后生成一个进程，内存分为 .data, heap, stack,  堆上内存可以自己分配，stack 自动分配释放，.data 的内存整个程序的声明周期都不会被释放。因此要自己控制内存扩容就只能定义在堆上。

msvc以 1.5 倍扩容（即 floor(1.5*capability)），而 linux 是两倍

> [面试题：C++vector的动态扩容，为何是1.5倍或者是2倍_vector扩容1.5倍,2倍区别-CSDN博客](https://blog.csdn.net/qq_44918090/article/details/120583540)

- **vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。**
- **为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用。**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/de5f27d7c5c32d81da5f14a178f39e7a.png)

### 数组双指针

比较短 20-30 行的算法适合在面试的时候出，因为面试可能没有机会用电脑写比较长的代码。

多刷题，归纳整理解题方法，遇到新题目会快速套 

### 链表

特点: 每一个节点都是在堆内存上独立 new 出来的， 节点内存不连续

优点:

1. 内存利用率高，不需要大块连续的内存
2. 插入，删除，时间复杂度为 O(1) （删除特定元素需要先找到，加上查找的时间复杂度为 O(n)）
3. 不需要专门的扩容操作

缺点：

1. 内存占用量大，每个节点除了数据还要存放地址
2. 节点内存不连续，无法随机访问，访问元素的复杂度为 O(n)
3. 搜索效率不高，只能从头节点逐节点遍历

感觉就是要关注数据结构的内存特点，以及 【访问，增，删，改，查】 的复杂度

### 

```c++
struct Node{
    int data;
    Node *next;
}
```

除了判断末尾节点是否为空时检查 `p->next != nullptr` 其他情况检查 `p != nullptr` 就好    

#### 单链表逆序

```c++
   void reverse(){
        if (head->next!=nullptr && head->next->next != nullptr) {
            std::cout << "test reverse" << std::endl;
            Node * o = head->next;
            Node * p = head->next->next;
            Node * q = head->next->next->next;
            o->next = nullptr;
            while (q!=nullptr) {
                // std::cout << p->data << std::endl;
                p->next = o;
                o=p;
                p=q;
                q=q->next;
            }
            p->next = o;
            head->next = p;
        }
        
    }
```

自己实现的第一个版本，时间复杂度应该是 O(n)

结果应该是头插法。。。

```
```

可以先画一下，搞清楚代码逻辑然后再写代码

对于代码的一些特殊值，边界值要做一些判断，否则程序崩溃，一分都没有
